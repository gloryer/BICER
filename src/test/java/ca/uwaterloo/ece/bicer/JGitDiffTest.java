package ca.uwaterloo.ece.bicer;
import org.junit.Test;

import ca.uwaterloo.ece.bicer.utils.Utils;

import static org.junit.Assert.*;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.util.List;

import org.eclipse.jgit.api.Git;
import org.eclipse.jgit.api.errors.GitAPIException;
import org.eclipse.jgit.api.errors.NoHeadException;
import org.eclipse.jgit.diff.DiffAlgorithm;
import org.eclipse.jgit.diff.DiffConfig;
import org.eclipse.jgit.diff.DiffEntry;
import org.eclipse.jgit.diff.DiffFormatter;
import org.eclipse.jgit.diff.RawText;
import org.eclipse.jgit.diff.RawTextComparator;
import org.eclipse.jgit.errors.RevisionSyntaxException;
import org.eclipse.jgit.lib.Config;
import org.eclipse.jgit.lib.ObjectId;
import org.eclipse.jgit.lib.ObjectReader;
import org.eclipse.jgit.lib.Repository;
import org.eclipse.jgit.patch.FileHeader;
import org.eclipse.jgit.revwalk.FollowFilter;
import org.eclipse.jgit.revwalk.RevCommit;
import org.eclipse.jgit.revwalk.RevWalk;
import org.eclipse.jgit.treewalk.CanonicalTreeParser;
import org.eclipse.jgit.util.io.DisabledOutputStream;

/*
 * This Java source file was auto generated by running 'gradle init --type java-library'
 * by 'j22nam' at '27/05/16 5:45 PM' with Gradle 2.13
 *
 * @author j22nam, @date 27/05/16 5:45 PM
 */
public class JGitDiffTest {
    @Test public void testSomeLibraryMethod() throws NoHeadException, GitAPIException {
        
    	Git git;
		try {
			git = Git.open( new File( System.getProperty("user.home") + "/Documents/ODP/projects/jackrabbit/git/") );
			
			Repository repo = git.getRepository();
			
			String oldSha1 = "6cbc271530d933d4c9910537fd8a83f089281ae0~1";
			String newSha1 = "6cbc271530d933d4c9910537fd8a83f089281ae0";
			String oldPath = "jackrabbit-ocm/src/main/java/org/apache/jackrabbit/ocm/manager/collectionconverter/impl/DefaultCollectionConverterImpl.java";
			String path = "jackrabbit-ocm/src/main/java/org/apache/jackrabbit/ocm/manager/collectionconverter/impl/DefaultCollectionConverterImpl.java";	
			
			// way 0
			ObjectId oldId;
			oldId = repo.resolve(oldSha1 + "^{tree}:");
			ObjectId newId = repo.resolve(newSha1 + "^{tree}");


			ObjectReader reader = repo.newObjectReader();

			// setting for renamed or copied path
			Config config = new Config();
			config.setBoolean("diff", null, "renames", true);
			config.setString("diff", null, "algorithm", "histogram");
			
			DiffConfig diffConfig = config.get(DiffConfig.KEY);

			CanonicalTreeParser oldTreeIter = new CanonicalTreeParser();
			oldTreeIter.reset(reader, oldId);
			CanonicalTreeParser newTreeIter = new CanonicalTreeParser();
			newTreeIter.reset(reader, newId);

			List<DiffEntry> diffs= git.diff()
					.setPathFilter(FollowFilter.create(path, diffConfig))
					.setNewTree(newTreeIter)
					.setOldTree(oldTreeIter)
					.call();

			//ByteArrayOutputStream out = new ByteArrayOutputStream();
			DiffFormatter df = new DiffFormatter(System.out);
			df.setDiffAlgorithm(Utils.diffAlgorithm);
			df.setDiffComparator(Utils.diffComparator);
			df.setRepository(repo);
			
			for(DiffEntry entry:diffs){

				/*FileHeader fileHeader = df.toFileHeader( entry );
				if(!fileHeader.getNewPath().equals(path))
					continue;*/

				df.format(entry);
			}
			
			df.close();
			
			// way 1
			
			Iterable<RevCommit> commits = git.log().call();    
			RevCommit newCommit=null;
		    for (RevCommit commit: commits)
		    {
		        if (commit.getName().equals(newSha1))
		        	newCommit = commit;
		    }
	
			//RevWalk revWalk = new RevWalk( repo );
			
			//ObjectId newId;
			//newId = ObjectId.fromString(newSha1);
			//RevCommit newCommit = revWalk.parseCommit( newId );
			RevCommit oldCommit = newCommit.getParent(0);
			//revWalk.close();
			
			//ByteArrayOutputStream out = new ByteArrayOutputStream();
			DiffFormatter df1 = new DiffFormatter(System.out);
			df1.setRepository(repo);
			df1.setDiffAlgorithm(Utils.diffAlgorithm);
			df1.setDiffComparator(Utils.diffComparator);
			df1.setDetectRenames(true);
			List<DiffEntry> diffs2;
			
				// do diff
				diffs2 = df1.scan(oldCommit.getTree(), newCommit.getTree());
				for (DiffEntry diff : diffs2) {
				
					//System.out.println(diff.getOldPath());
					//System.out.println(diff.getNewPath());
					
					FileHeader fileHeader = df1.toFileHeader( diff );
					if(!fileHeader.getNewPath().equals(path))
						continue;
	
					df1.format(diff);
				}
			

			df1.close();
			
			
			// way 2
			
			String sourceA = Utils.fetchBlob(repo, oldSha1, oldPath);
			String sourceB = Utils.fetchBlob(repo, newSha1, path);

			
			String sourceAWOComments = Utils.removeComments(Utils.fetchBlob(repo, oldSha1, oldPath));
			String sourceBWOComments = Utils.removeComments(Utils.fetchBlob(repo, newSha1, path));
			
						
			DiffAlgorithm diffAlgorithm = DiffAlgorithm.getAlgorithm(DiffAlgorithm.SupportedAlgorithm.MYERS);
			RawTextComparator diffComparator = RawTextComparator.WS_IGNORE_ALL;
			
			DiffFormatter df2 = new DiffFormatter(System.out);
			df2.setDiffAlgorithm(diffAlgorithm);
			df2.setDiffComparator(diffComparator);
			
			df2.format(Utils.getEditListFromDiff(sourceA, sourceB), new RawText(sourceA.getBytes()), new RawText(sourceB.getBytes()));
			df2.format(Utils.getEditListFromDiff(sourceAWOComments, sourceBWOComments), new RawText(sourceAWOComments.getBytes()), new RawText(sourceBWOComments.getBytes()));
			
			String a = "a\nb\n\n";
			String b = "a\n\nb\n";
			
			df2.format(Utils.getEditListFromDiff(a, b), new RawText(a.getBytes()), new RawText(b.getBytes()));
			df2.format(Utils.getEditListFromDiff(b, a), new RawText(b.getBytes()), new RawText(a.getBytes()));
			
			df2.close();

		} catch (IndexOutOfBoundsException e){

		}
		catch (RevisionSyntaxException | IOException e) {
			e.printStackTrace();
		}
		
		
    	//assertTrue("someLibraryMethod should return 'true'", classUnderTest.someLibraryMethod());
    }
}
